<!doctype html>
<html lang="en-US">
<!-- InstanceBegin template="/Templates/CanvasPage.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<!-- InstanceBeginEditable name="doctitle" -->
<title>Canvas Template</title>
<!-- InstanceEndEditable -->
<!--
<link rel="stylesheet" media="all" href="https://du11hjcvx0uqb.cloudfront.net/br/dist/brandable_css/69d640e59b804992771ec1fed57a5039/variables-8391c84da435c9cfceea2b2b3317ff66.css">
<link rel="stylesheet" media="all" href="https://du11hjcvx0uqb.cloudfront.net/br/dist/brandable_css/responsive_layout_normal_contrast/bundles/common-c626ffd3ae.css">
<link rel="stylesheet" media="all" href="https://du11hjcvx0uqb.cloudfront.net/br/dist/brandable_css/no_variables/bundles/wiki_page-46e7e026f6.css">
<link rel="stylesheet" media="all" href="https://instructure-uploads.s3.us-east-1.amazonaws.com/account_74070000000000001/attachments/1525105/canvas.css">
-->
<style>
body {
    margin-bottom: 5em;
    margin-top: 3em;
    margin-left: 20em;
    margin-right: 20em;
}
.section-header {
}
.section-body {
    padding: 0px 10px 10px 10px;
    border: solid #ccc 1px;
    overflow: hidden;
}
.show-content.user_content.clearfix.enhanced .section-body .checklist {
}
.checklist {
    list-style: none;
    margin-left: 0;
    padding-left: 1.2em;
    text-indent: -1.2em;
}
.checklist li:before {
    content: "‚ùë";
    display: block;
    float: left;
    width: 1.2em;
    color: #000000;
}
</style>
<!-- InstanceBeginEditable name="head" -->
<!-- InstanceEndEditable -->
</head>
<body>
<div class="show-content user_content clearfix enhanced">
  <h1 class="page-title">Canvas Page</h1>
  <!-- Start Custom HTML for Canvas Page --> 
  <!-- InstanceBeginEditable name="content" -->
  <h2 class="section-header">Announcements and Prayer</h2>
  <div class="section-body">
    <p>Assignment: </p>
    <ul>
      <li>The functions assignment should be up on Canvas</li>
    </ul>
    <p>Class schedule:</p>
    <ul>
      <li>Back to normal (For now at least)</li>
    </ul>
  </div>
  <h2 class="section-header">Review Homework</h2>
  <div class="section-body">
    <p>Booleans and Branching, Lists</p>
  </div>
  <h2 class="section-header">Daily Topic - Functions</h2>
  <div class="section-body">
    <p>What is wrong with the following code:
    <pre>
	<code>
	dog_name = 'Kitty'
	dog_weight = 45
	if dog_weight > 20:
		print(dog_name, 'says WOOF WOOF')
	else:
		print(dog_name, 'says woof woof')

	dog_name = 'Sparky'
	dog_weight = 15
	if dog_weight > 20:
		print(dog_name, 'says WOOF WOOF')
	else:
		print(dog_name, 'says woof woof')

	dog_name = 'Jackson'
	dog_weight = 12
	if dog_weight > 20:
		print(dog_name, 'says WOOF WOOF')
	else:
		print(dog_name, 'says woof woof')

	dog_name = 'Range'
	dog_weight = 65
	if dog_weight > 20:
		print(dog_name, 'says WOOF WOOF')
	else:
		print(dog_name, 'says woof woof')
	</code>
	</pre>
    </p>
    <p>Coding Mantra:</p>
    <h3>Don't Repeat Yourself (DRY)</h3>
    <p>Why would this be such a common coding mantra?</p>
    <h5>DRY</h5>
    <ol>
      <li>Slows you down
        <ul>
          <li>Requires a lot of typing</li>
          <li>Requires you to solve the same problems again and again</li>
        </ul>
      </li>
      <li>Increase the chance of errors
        <ul>
          <li>Anytime you type something in you have a chance of creating errors</li>
          <li>The probability of an error accumulates with the amount of input</li>
          <li>Copying has the same problem only a little more pernicious.  It is really easy to forget to make a small necessary change in copied code.</li>
        </ul>
      </li>
      <li>Making changes or bug fixes becomes much harder</li>
      <li>Makes it hard to reuse code in different places or programs</li>
    </ol>
    <h3>Functions</h3>
    <p>Functions solve these problems.  They allow us to take a block of code and:
    <ul>
      <li>Give it a name</li>
      <li>Call it by name and have it execute the logic</li>
    </ul>
    </p>
    <p>You have already been using functions:
    <ul>
      <li><code>print(....)</code> - Think about the steps a computer requires to actually display something to the screen</li>
      <li><code>randint(1, 3)</code></li>
      <li>str(...)</li>
    </ul>
    You can tell that these are functions because they have a name followed by a set of parenthesis.
    </p>
    <p>Most of what you will be doing in programming is calling functions that other people have written.  Your job is thus one of finding a function that does what you want, figuring out how to call it, and combining this function with other functions into a program.</p>
    <p>Functions are a lot like variables
    <table width="100" border="0">
      <tbody>
        <tr>
          <th scope="col">Variables</th>
          <th scope="col">Functions</th>
        </tr>
        <tr>
          <td>Name</td>
          <td>Name</td>
        </tr>
        <tr>
          <td>Type</td>
          <td>Return type</td>
        </tr>
        <tr>
          <td>Value</td>
          <td>Programming Logic</td>
        </tr>
      </tbody>
    </table>
    Unlike variables however, a functions expression is evaluated when it is called rather than when it is defined.
    </p>
    <p>Just like variables can't be used before they are defined, functions must be defined before they are called.</p>
    <h3>API</h3>
    <p>A set of functions that have been packaged together is usually called an API.  (Python calls it a "Module.") Learning an API is the biggest task in programming, but is what will make you an efficient and effective programmer.</p>
    <h3>Functions in Python</h3>
    <p>You can create your own functions if you can't find something that does what you want.
    <pre>
	<code>
	def bark(name, weight):
		if weight > 20:
			print(name, 'says WOOF WOOF')
		else:
			print(name, 'says woof woof')
	</code>
	</pre>
    <ul>
      <li>def - Tells Python that you are defining a function.</li>
      <li>bark - The name of the function</li>
      <li>(name, weight) - The functions parameters.  Functions can have 0 or more parameters.  (These are variables that serve as a bridge between the calling code and the function.)</li>
      <li>if weight ... - The function body</li>
    </ul>
    </p>
    <p>You can call a function with the name of the function, open parenthesis, value for each parameter, close parenthesis
    <pre>
	<code>
	bark('Kitty', 45)
	bark('Sparky', 15)
	bark('Jackson', 12)
	bark('Ranger', 65)
	</code>
	</pre>
    </p>
    <p>How functions work
    <ul>
      <li>When a function is defined, none of the logic is executed.  It is simply stored so it can be called later.</li>
      <li>When a function is called, the function call is "expanded" and the logic of the function replaces the function call.</li>
    </ul>
    Essentially
    <pre>
	<code>
	bark('Kitty', 45)
	</code>
	</pre>
    is expanded into
    <pre>
	<code>
	bark.name = 'Kitty'
	bark.weight = 45
	if bark.weight > 20:
		print(bark.name, 'says WOOF WOOF')
	else:
		print(bark.name, 'says woof woof')
	</code>
	</pre>
    the "bark." prefix to the variables is just to denote that the variables only apply to this specific bit of code that was part of the bark function.  More on this later today.
    </p>
    <h3>Encapsulation and Abstraction</h3>
    <p>Functions serve two additional purposes:
    <dl>
      <dt>Encapsulation</dt>
      <dd>Code is logically grouped into a compact set of actions that should always be preformed together.  Code that is not part of the group cannot access or change code in the group and the code in the group should not affect code outside the grouping.</dd>
      <dt>Abstraction</dt>
      <dd>The process of collapsing a set of instructions into a higher level concept that refers to the individual details. Allows you to think at a higher level than a computer instruction.</dd>
    </dl>
    </p>
    <h5>Abstraction</h5>
    <p>Example: Make a sandwich</p>
    <p>Highest level of abstraction:
    <pre>
	<code>
	make_sandwich(peanut_butter, strawberry_jam)
	</code>
	</pre>
    </p>
    <p>Lower level abstraction:
    <pre>
	<code>
	get(white_bread)
	get(peanut_butter)
	get(strawberry_jam)
	put(white_bread.slice, counter)
	spread(peanut_butter)
	spread(strawberry_jam)
	put(white_bread.slice, strawberry_jam)
	put_away(white_bread)
	put_away(peanut_butter)
	put_away(strawberry_jam)
	eat(sandwich)
	</code>
	</pre>
    </p>
    <p>Even lower level of abstraction:
    <pre>
	<code>
	walk to pantry
	search for white bread
	pick up white bread
	carry to kitchen counter
	place on kitch counter
	...
	</code>
	</pre>
    </p>
    <p>And so it continues to individual brain signals dictating specific muscle movements.</p>
    <p>The higher the level of abstraction, the easier a problem is to reason about, but the less general the solution.  There is a point where the problem is so abstract that it is not longer a good solution.  For example make lunch is probably to high a level of abstraction to be useful without additional clarification.</p>
    <p>One of the keys to being a good programmer is being able to think at multiple levels of abstraction and then work at the appropriate level for the current problem. That is one of the keys to pseudo-code.  You start at a high level of abstraction and then slowly expand until you are at a level where it makes sense to start actual programming.  Pseudo-code is so effective because it aids in moving up and down the abstraction ladder.</p>
    <h5>Encapsulation</h5>
    <p>One of the primary principles of encapsulation is the idea of "variable scope." We have briefly touched on it before, but it becomes essential to understand when working with functions.  You can define variables inside a function, but they are said to be "local" because they do not exist outside of the function.</p>
    <p>Function parameters are technically local variables.  They are just defined and assigned during the function call instead of with the = operator.</p>
    <p>Scope means that you can have the same variable name inside a function that you use in your main program.  I try not to do this however as it causes confusion when you or somebody else is trying to read your code.  It still happens accidentally all the time.  Especially with variables that are slightly generic like "data".</p>
    <p>Variables that are defined outside of a function are called "global" variables. The technical rule is that they can global because they can be read from any part of your program.  In Python they can only be written to if you explicitly tag the variable inside your function.</p>
    <p>Example code:
    <pre>
	<code>
	greeting = 'Greetings'

	def greet(name, message):
    	print(greeting, name + '.', message)

	greet('June', 'See you soon!')
	</code>
	</pre>
    The output of this code is <code>Greetings June. See you soon!</code>. Notice that the variable greeting can be accessed from inside the function.
    </p>
    <p>Example 2:
    <pre>
	<code>
	greeting = 'Greetings'

	def greet(name, message):
		greeting = 'Hi'
		print(greeting, name + '.', message)

	greet('June', 'See you soon!')
	print(greeting)
	</code>
	</pre>
    For this code the output is:
    <pre>
	<code>
	Hi June, See you soon!
	Greetings
	</code>
	</pre>
    Notice that we didn't change the greetings variable even though it looks like it was overwritten inside the function.  This is because the variable inside the function was treated as if it were a brand new variable.  It "masks" or "shadows" the previously defined variable as long as the execution is inside the function.
    </p>
    <p>A final example:
    <pre>
	<code>
	greeting = 'Greetings'

	def greet(name, message):
		global greeting
		greeting = 'Hi'
		print(greeting, name + '.', message)

	greet('June', 'See you soon!')
	print(greeting)
	</code>
	</pre>
    the output for this code is:
    <pre>
	<code>
	Hi June. See you soon!
	Hi
	</code>
	</pre>
    Notice that the value of the greeting variable was changed inside the function.  This is because we tagged the variable name with the global keyword to tell Python that the variable name was referring to the global variable.
    </p>
    <p>The global keyword is a sign of "code smell" - bad code - that could cause a lot of weird errors.  I don't think that I have ever needed to use it.  Using "global" violates the principle of encapsulation.</p>
    <h3>Return Values</h3>
    <p>We call a function for two primary purposes:
    <ol>
      <li>Compute an answer and return the result</li>
      <li>Do something that produces a "side effect" - an action that changes the state of something outside the function</li>
    </ol>
    </p>
    <p>Examples:
    <ol>
      <li><code>randint(1, 6)</code> - we want the result of the pseudo-random number generator algorithm that the function returns</li>
      <li><code>print('Hello')</code> - we want something changed on the screen.  (Not actually a part of our program.  We actually don't care about the return value of the function.  We just want the side effect.</li>
    </ol>
    </p>
    <h3>Programming Best Practice</h3>
    <p>Your functions should either be written to return a result or perform a side-effect, but not both.</p>
    <p>You return a value from a function with the <code>return</code> statement:
    <pre>
	<code>
	def get_bark(weight):
    if weight > 20:
        return 'WOOF WOOF'
    else:
        return 'woof woof'
	</code>
	</pre>
    </p>
    <p>A function ends immediately after it reaches a return statement.  Nothing after the statement is executed.  While I don't recommend this code, it is equivalent to the previous code:
    <pre>
	<code>
	def get_bark(weight):
    if weight > 20:
        return 'WOOF WOOF'
    return 'woof woof'
	</code>
	</pre>
    </p>
    <p>Function calls of a function with a return statement should be assigned to a variable or immediately used.  Functions called for side effects are almost always on a line by themselves.</p>
    <h3>Refactoring</h3>
    <p>Refactoring is refining or editing code to make it more clear or change the level of abstraction.  Generally the output before or after a refactor will be the same.</p>
    <p>Debugging is fixing errors in code.  There are three types of errors:
    <ol>
      <li>Syntax Errors - Code that won't even start running because the Python is not properly written.  Easiest to catch as Python will tell you the exact place of the error.</li>
      <li>Runtime Errors - Code that will crash in the middle of running the program. While harder than runtime errors, Python will tell you exactly where the crash occurs and may be able to tell you why that section of code crashed.</li>
      <li>Logic Errors - Code that runs properly, but produces the wrong results.  This is the hardest type of error to find and fix as Python will not tell you about these types of errors.  You have to find them by testing and running your code in a lot of different situations.</li>
    </ol>
    </p>
    <h3>Special Python Considerations</h3>
    <ol>
      <li>You can give functions default values:
        <pre>
	<code>
	def greet(name, message='You rule!')
    	print('Hi', name + '.', message)

	greet('John') # Hi John. You rule!
	greet('Jennifer', 'How are you today?') # Hi Jennifer, How are you today?
	</code>
	</pre>
        Required parameters (parameters without default values) must come before parameters with default values.
        <pre>
	<code>
	def greet(message='You rule!', name):
	    print('Hi', name + '.', message)
	</code>
	</pre>
        Produces a <code>SyntaxError: non-default argument follows default argument</code></li>
      <li>When calling a function you can supply parameter names,  This means that you can supply the parameters in any order.
        <pre>
	<code>
	greet('John', 'Howdy partner!')
	</code>
	</pre>
        is the same as
        <pre>
	<code>
	greet(message='Howdy partner!', name = 'John')
	</code>
	</pre>
        Unnamed parameters must come in the function call before named parameters.</li>
    </ol>
  </div>
  <h2 class="section-header">Homework Assignment</h2>
  <div class="section-body">
    <p>Complete the Functions assignment</p>
  </div>
  <!-- InstanceEndEditable --> 
  <!-- End custom HTML for Canvas Page --> 
</div>
</body>
<!-- InstanceEnd -->
</html>
